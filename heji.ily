\version "2.24.1"

heji-font = #(if (nil? (ly:parser-lookup 'heji-font)) "HEJI2" heji-font)

hash = #(define-scheme-function (factor exponent)
          (number? number?)
          (* factor exponent))

low-primes = #'(7 11 13 17 19)

prime = #(define-scheme-function (i)
           (number?)
           (list-ref low-primes i))

accidental-map = #`((,(hash 3 0) . #x6e)
                    (,(hash 3 1) . #x76)
                    (,(hash 3 2) . #x56)
                    (,(hash 3 -1) . #x65)
                    (,(hash 3 -2) . #x45)
                    (,(hash 5 1) . #x6f)
                    (,(hash 5 2) . #x70)
                    (,(hash 5 3) . #x71)
                    (,(hash 5 4) . #x4e)
                    (,(hash 5 -1) . #x6d)
                    (,(hash 5 -2) . #x6c)
                    (,(hash 5 -3) . #x6b)
                    (,(hash 5 -4) . #x4d)
                    (,(hash (* 5 (prime 3)) 1) . #x77)
                    (,(hash (* 5 (prime 3)) 2) . #x78)
                    (,(hash (* 5 (prime 3)) 3) . #x79)
                    (,(hash (* 5 (prime 3)) 4) . #x50)
                    (,(hash (* 5 (prime 3)) -1) . #x75)
                    (,(hash (* 5 (prime 3)) -2) . #x74)
                    (,(hash (* 5 (prime 3)) -3) . #x73)
                    (,(hash (* 5 (prime 3)) -4) . #x4f)
                    (,(hash (* 5 (prime 4)) 1) . #x57)
                    (,(hash (* 5 (prime 4)) 2) . #x58)
                    (,(hash (* 5 (prime 4)) 3) . #x59)
                    (,(hash (* 5 (prime 4)) 4) . #x51)
                    (,(hash (* 5 (prime 4)) -1) . #x55)
                    (,(hash (* 5 (prime 4)) -2) . #x54)
                    (,(hash (* 5 (prime 4)) -3) . #x53)
                    (,(hash (* 5 (prime 4)) -4) . #x52)
                    (,(hash (* 5 (prime 1)) 1) . #x66)
                    (,(hash (* 5 (prime 1)) 2) . #x67)
                    (,(hash (* 5 (prime 1)) 3) . #x68)
                    (,(hash (* 5 (prime 1)) 4) . #x4c)
                    (,(hash (* 5 (prime 1)) -1) . #x64)
                    (,(hash (* 5 (prime 1)) -2) . #x63)
                    (,(hash (* 5 (prime 1)) -3) . #x62)
                    (,(hash (* 5 (prime 1)) -4) . #x4b)
                    (,(hash (* 5 (prime 0)) 1) . #x46)
                    (,(hash (* 5 (prime 0)) 2) . #x47)
                    (,(hash (* 5 (prime 0)) 3) . #x48)
                    (,(hash (* 5 (prime 0)) 4) . #x4a)
                    (,(hash (* 5 (prime 0)) -1) . #x44)
                    (,(hash (* 5 (prime 0)) -2) . #x43)
                    (,(hash (* 5 (prime 0)) -3) . #x42)
                    (,(hash (* 5 (prime 0)) -4) . #x49)
                    (,(hash 7 1) . #x3e)
                    (,(hash 7 2) . #x2e)
                    (,(hash 7 -1) . #x3c)
                    (,(hash 7 -2) . #x2c)
                    (,(hash 11 1) . #x34)
                    (,(hash 11 -1) . #x35)
                    (,(hash 13 1) . #x39)
                    (,(hash 13 -1) . #x30)
                    (,(hash 17 1) . #x3b)
                    (,(hash 17 -1) . #x3a)
                    (,(hash 19 1) . #x2f)
                    (,(hash 19 -1) . #x2a)
                    (,(hash 23 1) . #x33)
                    (,(hash 23 -1) . #x36)
                    (,(hash 29 1) . #x32)
                    (,(hash 29 -1) . #x37)
                    (,(hash 31 1) . #x38)
                    (,(hash 31 -1) . #x31))

prime-p = #(define-scheme-function (n)
             (number?)
             (define (aux k)
               (cond ((> (* k k) n) #t)
                     ((= (modulo n k) 0) #f)
                     (else (aux (+ k 1)))))
             (if (<= n 1)
                 #f
                 (aux 2)))

ignore = #(define-scheme-function (msg x)
            (string? scheme?)
            (begin (ly:warning msg) x))

valid-prime-exponent = #(define-scheme-function (factor exponent)
                          (number? number?)
                          (let ((max-exponent (cond ((= factor 3) 2)
                                                    ((= factor 5) 4)
                                                    ((= factor 7) 2)
                                                    (else 1))))
                            (cond
                             ((not (prime-p factor))
                              (ly:error (format #f "~d is not a prime factor." factor)))
                             ((> (abs exponent) max-exponent)
                              (ly:error (format #f "~d-limit accidentals currently only support a maximum exponent of Â±~d." factor max-exponent)))
                             (else #t))))

normalize-factors = #(define-scheme-function (factors)
                       (list?)
                       (if (nil? factors)
                           factors
                           (let* ((this-factor (car factors))
                                  (rest (cdr factors))
                                  (f (car this-factor))
                                  (e (cdr this-factor)))
                             (cond
                              ((or (= f 2) (= e 0)) (normalize-factors rest))
                              ((not (nil? rest))
                               (let* ((that-factor (cadr factors))
                                      (f1 f)
                                      (f2 (car that-factor))
                                      (e1 e)
                                      (e2 (cdr that-factor)))
                                 (cond ((= f1 f2)
                                        (cons (cons f1 (+ e1 e2))
                                              (normalize-factors (cdr rest))))
                                       ((= e2 0) (normalize-factors (cons this-factor (cdr rest))))
                                       ((and (= f1 3) (= f2 5))
                                        (cons (cons (hash 5 (prime (+ e1 2)))
                                                    e2)
                                              (normalize-factors (cdr rest))))
                                       (else (cons this-factor (normalize-factors rest))))))
                              (else (list this-factor))))))

parse-heji = #(define-scheme-function (factors)
                (list?)
                (let* ((valid-factors (filter
                                       (lambda
                                        (factor-exponent)
                                        (valid-prime-exponent (car factor-exponent) (cdr factor-exponent)))
                                       factors))
                       (sorted-factors (sort valid-factors (lambda (fe1 fe2) (< (car fe1) (car fe2)))))
                       (normalized-factors (let ((normalized (normalize-factors sorted-factors)))
                                             (if (nil? normalized)
                                                 (ignore "Interpreting empty factor list as natural accidental" '((3 . 0)))
                                                 normalized)))
                       (indices (map
                                 (lambda (factor-exponent)
                                   (let ((factor (car factor-exponent))
                                         (exponent (cdr factor-exponent)))
                                     (hash factor exponent)))
                                 normalized-factors)))
                  (map
                   (lambda (index)
                     (assoc-ref accidental-map index))
                   (reverse indices))))

#(define-markup-command
  (heji-markup layout props factors)
  (list?)
  (let* ((accidentals
          (map
           (lambda (point-code)
             `(#:override `(font-name . ,heji-font) #:fontsize 5 #:char ,point-code))
           (parse-heji factors)))
         (markup-cmd `(markup ,@accidentals)))
    (interpret-markup layout props
                      (eval markup-cmd (current-module)))))

heji =
#(define-music-function (factors note)
   (list? ly:music?)
   #{
     \once \override Voice.Accidental.stencil =
     #ly:text-interface::print
     \once \override Voice.Accidental.text =
     \markup\heji-markup #factors
     #(ly:music-set-property! note 'force-accidental #t)
     $note
   #})